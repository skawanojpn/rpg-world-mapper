<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>rpg-world-mapper v5.4</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; display: flex; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; z-index: 100; width: 300px; border: 1px solid #444; }
        .view-container { width: 50vw; height: 100vh; position: relative; border-right: 1px solid #333; }
        .label { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #4fc3f7; background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 20px; pointer-events: none; font-weight: bold; border: 1px solid #4fc3f7; text-transform: uppercase; }
        input[type="file"] { width: 100%; margin-top: 10px; cursor: pointer; color: #ccc; }
        .instruction { font-size: 11px; color: #aaa; margin-top: 10px; line-height: 1.5; white-space: pre-wrap; }
    </style>
</head>
<body>

<div id="ui">
    <h2 style="margin:0; font-size: 16px;">RPG WORLD MAPPER v5.4</h2>
    <input type="file" id="fileInput" accept="image/*">
    <div class="instruction">もし地球の南北が古のJRPGの様につながっていたら。もしくは古のJRPGが地球と同じ球体だったら。</div>
</div>

<div id="view1" class="view-container"><div class="label">Sphere</div></div>
<div id="view2" class="view-container"><div class="label">Torus</div></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const SPHERE_RADIUS = 5;
    const TORUS_MINOR_RADIUS = 1.6; 
    const TORUS_MAJOR_RADIUS = SPHERE_RADIUS - TORUS_MINOR_RADIUS;

    let views = [];
    let lastUV = { u: 0.5, v: 0.5 };
    let commonTexture;
    let activeController = null;
    const textureLoader = new THREE.TextureLoader();
    const earthMapUrl = './earth.jpg';

    function init() {
        commonTexture = textureLoader.load(earthMapUrl, (tex) => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            views.forEach(v => v.mesh.material.map = tex);
        });

        setupView('view1', false); 
        setupView('view2', true);  
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                        tex.needsUpdate = true;
                        commonTexture = tex;
                        views.forEach(v => v.mesh.material.map = tex);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        animate();
    }

    function setupView(containerId, isTorus) {
        const container = document.getElementById(containerId);
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, (window.innerWidth/2) / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth / 2, window.innerHeight);
        container.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 2.0));

        const geo = isTorus 
            ? new THREE.TorusGeometry(TORUS_MAJOR_RADIUS, TORUS_MINOR_RADIUS, 128, 128) 
            : new THREE.SphereGeometry(SPHERE_RADIUS, 128, 128);

        const uvAttr = geo.attributes.uv;
        for (let i = 0; i < uvAttr.count; i++) {
            let u = uvAttr.getX(i);
            let v = uvAttr.getY(i);
            if (isTorus) {
                // 表示上の南北を正しく。v=1を上（穴の内側上）に。
                v = 1 - ((v + 0.5) % 1.0); 
            }
            uvAttr.setXY(i, u, v);
        }

        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ map: commonTexture, side: THREE.DoubleSide }));
        
        if (isTorus) {
            mesh.rotation.x = Math.PI / 2;
            mesh.rotation.z = -Math.PI / 2;
        } else {
            mesh.scale.x = -1; 
            mesh.rotation.y = Math.PI / 2;
        }
        scene.add(mesh);

        const pin = new THREE.Mesh(
            new THREE.ConeGeometry(0.12, 0.5, 12),
            new THREE.MeshPhongMaterial({ color: 0xff0000 })
        );
        pin.rotation.x = Math.PI;
        scene.add(pin);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener('start', () => { activeController = view; });
        
        const view = { scene, camera, renderer, mesh, pin, isTorus, controls };
        views.push(view);

        renderer.domElement.addEventListener('mousedown', (e) => onMapClick(e, view));
    }

    function onMapClick(event, activeView) {
        const rect = activeView.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, activeView.camera);
        const intersects = raycaster.intersectObject(activeView.mesh);

        if (intersects.length > 0 && intersects[0].uv) {
            lastUV = { u: intersects[0].uv.x, v: intersects[0].uv.y };
            updateAllPins();
        }
    }

    function updateAllPins() {
        views.forEach(v => {
            const { u, v: v_coord } = lastUV;
            const theta = (u * Math.PI * 2) - Math.PI / 2;

            if (!v.isTorus) {
                // 球体：v=1(北)がy正方向
                const phi = (1 - v_coord) * Math.PI; 
                const r = SPHERE_RADIUS + 0.05;
                v.pin.position.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );
            } else {
                // ドーナツ：南北の計算を反転
                // v=1(北)のとき、y座標がプラス(断面の上側)になるように phi の符号を調整
                const phi = (v_coord - 0.5) * Math.PI * 2; 
                const R = TORUS_MAJOR_RADIUS;
                const r = TORUS_MINOR_RADIUS + 0.05;

                v.pin.position.set(
                    (R + r * Math.cos(phi)) * Math.cos(theta),
                    r * Math.sin(phi), // ここが北緯・南緯の高さ。v_coord=1なら正、v_coord=0なら負。
                    (R + r * Math.cos(phi)) * Math.sin(theta)
                );
            }
            v.pin.lookAt(0,0,0);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if (activeController) {
            const otherView = views.find(v => v !== activeController);
            if (otherView) {
                otherView.camera.position.copy(activeController.camera.position);
                otherView.camera.quaternion.copy(activeController.camera.quaternion);
                otherView.controls.target.copy(activeController.controls.target);
                otherView.controls.update();
            }
        }
        views.forEach(v => {
            v.renderer.render(v.scene, v.camera);
        });
    }

    init();
    window.addEventListener('resize', () => {
        views.forEach(v => {
            v.camera.aspect = (window.innerWidth/2) / window.innerHeight;
            v.camera.updateProjectionMatrix();
            v.renderer.setSize(window.innerWidth / 2, window.innerHeight);
        });
    });
</script>
</body>
</html>