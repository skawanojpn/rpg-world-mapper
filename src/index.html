<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>rpg-world-mapper v5.4.2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; display: flex; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; z-index: 100; width: 300px; border: 1px solid #444; }
        .view-container { width: 50vw; height: 100vh; position: relative; border-right: 1px solid #333; }
        .label { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #4fc3f7; background: rgba(0,0,0,0.6); padding: 8px 20px; border-radius: 20px; pointer-events: none; font-weight: bold; border: 1px solid #4fc3f7; text-transform: uppercase; }
        
        .control-group { margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        input[type="file"] { width: 100%; cursor: pointer; color: #ccc; font-size: 12px; }
        
        button { 
            background: #333; color: white; border: 1px solid #666; padding: 6px 12px; 
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: 0.2s;
        }
        button:hover { background: #444; border-color: #4fc3f7; }
        button:active { background: #222; }

        .instruction { font-size: 11px; color: #aaa; margin-top: 10px; line-height: 1.5; white-space: pre-wrap; }
    </style>
</head>
<body>

<div id="ui">
    <h2 style="margin:0; font-size: 16px;">RPG WORLD MAPPER v5.4.2</h2>
    <div class="control-group">
        <input type="file" id="fileInput" accept="image/*">
        <div style="display: flex; gap: 5px;">
            <button id="loadEarthBtn" style="flex: 1;">現実の地球</button>
            <button id="loadRpgBtn" style="flex: 1;">幻想の世界</button>
        </div>
    </div>
    <div class="instruction">もし地球の南北が古のJRPGの様につながっていたら。もしくは古のJRPGが地球と同じ球体だったら。</div>
</div>

<div id="view1" class="view-container"><div class="label">Sphere</div></div>
<div id="view2" class="view-container"><div class="label">Torus</div></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const SPHERE_RADIUS = 5;
    const TORUS_MINOR_RADIUS = 1.6; 
    const TORUS_MAJOR_RADIUS = SPHERE_RADIUS - TORUS_MINOR_RADIUS;
    const DEFAULT_MAP_URL = './earth.jpg';
    const RPG_MAP_URL = './rpg.png';

    let views = [];
    let lastUV = { u: 0.5, v: 0.5 };
    let commonTexture;
    let activeController = null;
    const textureLoader = new THREE.TextureLoader();

    function init() {
        // v5.4の初期ロード処理を関数化して再利用可能に
        loadMap(DEFAULT_MAP_URL);

        setupView('view1', false); 
        setupView('view2', true);  
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                        tex.needsUpdate = true;
                        commonTexture = tex;
                        views.forEach(v => v.mesh.material.map = tex);
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

document.getElementById('loadEarthBtn').addEventListener('click', () => {
        loadMap(DEFAULT_MAP_URL);
        document.getElementById('fileInput').value = ""; 
    });

    // 現実の地球ボタン
    document.getElementById('loadEarthBtn').addEventListener('click', () => {
        loadMap(DEFAULT_MAP_URL);
        document.getElementById('fileInput').value = ""; 
    });

    // RPG風マップボタン
    document.getElementById('loadRpgBtn').addEventListener('click', () => {
        loadMap(RPG_MAP_URL);
        document.getElementById('fileInput').value = ""; 
    });

        animate();
    }

    // v5.4準拠のテクスチャ適用関数
    function loadMap(url) {
        textureLoader.load(url, (tex) => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            commonTexture = tex;
            views.forEach(v => {
                v.mesh.material.map = tex;
                v.mesh.material.needsUpdate = true;
            });
        });
    }

    function setupView(containerId, isTorus) {
        const container = document.getElementById(containerId);
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, (window.innerWidth/2) / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth / 2, window.innerHeight);
        container.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 2.0));

        // v5.4 ジオメトリ作成
        const geo = isTorus 
            ? new THREE.TorusGeometry(TORUS_MAJOR_RADIUS, TORUS_MINOR_RADIUS, 128, 128) 
            : new THREE.SphereGeometry(SPHERE_RADIUS, 128, 128);

        // v5.4 UVロジック（そのまま）
        const uvAttr = geo.attributes.uv;
        for (let i = 0; i < uvAttr.count; i++) {
            let u = uvAttr.getX(i);
            let v = uvAttr.getY(i);
            if (isTorus) {
                v = 1 - ((v + 0.5) % 1.0); 
            }
            uvAttr.setXY(i, u, v);
        }

        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ map: commonTexture, side: THREE.DoubleSide }));
        
        // v5.4 配置・反転ロジック（そのまま）
        if (isTorus) {
            mesh.rotation.x = Math.PI / 2;
            mesh.rotation.z = -Math.PI / 2;
        } else {
            mesh.scale.x = -1; 
            mesh.rotation.y = Math.PI / 2;
        }
        scene.add(mesh);

        const pin = new THREE.Mesh(
            new THREE.ConeGeometry(0.12, 0.5, 12),
            new THREE.MeshPhongMaterial({ color: 0xff0000 })
        );
        pin.rotation.x = Math.PI;
        scene.add(pin);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener('start', () => { activeController = view; });
        
        const view = { scene, camera, renderer, mesh, pin, isTorus, controls };
        views.push(view);

        renderer.domElement.addEventListener('mousedown', (e) => onMapClick(e, view));
    }

    function onMapClick(event, activeView) {
        const rect = activeView.renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, activeView.camera);
        const intersects = raycaster.intersectObject(activeView.mesh);

        if (intersects.length > 0 && intersects[0].uv) {
            lastUV = { u: intersects[0].uv.x, v: intersects[0].uv.y };
            updateAllPins();
        }
    }

    function updateAllPins() {
        views.forEach(v => {
            const { u, v: v_coord } = lastUV;
            
            // v5.4 同期ロジック（そのまま）
            const theta = (u * Math.PI * 2) - Math.PI / 2;

            if (!v.isTorus) {
                const phi = (1 - v_coord) * Math.PI; 
                const r = SPHERE_RADIUS + 0.05;
                v.pin.position.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );
            } else {
                const phi = (v_coord - 0.5) * Math.PI * 2; 
                const R = TORUS_MAJOR_RADIUS;
                const r = TORUS_MINOR_RADIUS + 0.05;

                v.pin.position.set(
                    (R + r * Math.cos(phi)) * Math.cos(theta),
                    r * Math.sin(phi),
                    (R + r * Math.cos(phi)) * Math.sin(theta)
                );
            }
            v.pin.lookAt(0,0,0);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if (activeController) {
            const otherView = views.find(v => v !== activeController);
            if (otherView) {
                otherView.camera.position.copy(activeController.camera.position);
                otherView.camera.quaternion.copy(activeController.camera.quaternion);
                otherView.controls.target.copy(activeController.controls.target);
                otherView.controls.update();
            }
        }
        views.forEach(v => {
            v.renderer.render(v.scene, v.camera);
        });
    }

    init();
    window.addEventListener('resize', () => {
        views.forEach(v => {
            v.camera.aspect = (window.innerWidth/2) / window.innerHeight;
            v.camera.updateProjectionMatrix();
            v.renderer.setSize(window.innerWidth / 2, window.innerHeight);
        });
    });
</script>
</body>
</html>